#include "stdafx.h"
#include "SkinModel.h"
#include "SkinModelDataManager.h"
#include "graphics/Shader.h"
#include "graphics/SkinModelEffect.h"

SkinModel::SkinModel()
{
}

SkinModel::~SkinModel()
{
	if (m_cb != nullptr) {
		//定数バッファを解放。
		m_cb->Release();
	}
	if (m_samplerState != nullptr) {
		//サンプラステートを解放。
		m_samplerState->Release();
	}
	if (m_light != nullptr) {
		m_light->Release();
	}
	if (m_silhouettoDepthStepsilState != nullptr) {
		m_silhouettoDepthStepsilState->Release();
	}
}
void SkinModel::Init(const wchar_t* filePath, EnFbxUpAxis enFbxUpAxis)
{
	//スケルトンのデータを読み込む。
	InitSkeleton(filePath);

	//定数バッファの作成。
	InitConstantBuffer();

	//サンプラステートの初期化。
	InitSamplerState();

	InitShader();

	InitDirectionLight();

	InitPointLight();

	InitSilhouettoDepthStepsilState();
	
	//SkinModelDataManagerを使用してCMOファイルのロード。
	m_modelDx = g_skinModelDataManager.Load(filePath, m_skeleton);

	m_enFbxUpAxis = enFbxUpAxis;
}
void SkinModel::InitSkeleton(const wchar_t* filePath)
{
	//スケルトンのデータを読み込む。
	//cmoファイルの拡張子をtksに変更する。
	std::wstring skeletonFilePath = filePath;
	//文字列から.cmoファイル始まる場所を検索。
	int pos = (int)skeletonFilePath.find(L".cmo");
	//.cmoファイルを.tksに置き換える。
	skeletonFilePath.replace(pos, 4, L".tks");
	//tksファイルをロードする。
	bool result = m_skeleton.Load(skeletonFilePath.c_str());
	if ( result == false ) {
		//スケルトンが読み込みに失敗した。
		//アニメーションしないモデルは、スケルトンが不要なので
		//読み込みに失敗することはあるので、ログ出力だけにしておく。
#ifdef _DEBUG
		char message[256];
		sprintf(message, "tksファイルの読み込みに失敗しました。%ls\n", skeletonFilePath.c_str());
		OutputDebugStringA(message);
#endif
	}
}
void SkinModel::InitShader()
{
	m_vsShader.Load("Assets/shader/model.fx","VSMain", ksEngine::Shader::EnType::VS);
	m_psShader.Load("Assets/shader/model.fx", "PSMain", ksEngine::Shader::EnType::PS);

	m_psSilhouette.Load("Assets/shader/model.fx", "PSMain_Silhouette", ksEngine::Shader::EnType::PS);
}

void SkinModel::InitSilhouettoDepthStepsilState()
{
	//D3Dデバイスを取得。
	auto pd3d = g_graphicsEngine->GetD3DDevice();
	//作成する深度ステンシルステートの定義を設定していく。
	D3D11_DEPTH_STENCIL_DESC desc = { 0 };
	desc.DepthEnable = true;						   //Zテストが有効。
	desc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ZERO; //ZバッファにZ値を描き込まない。
	desc.DepthFunc = D3D11_COMPARISON_GREATER;		   //Z値が大きければフレームバッファに描き込む。

	pd3d->CreateDepthStencilState(&desc, &m_silhouettoDepthStepsilState);
}

void SkinModel::InitPointLight()
{
	for (auto& pt : m_pointLight) {
		pt.position.x = 00.0;
		pt.position.y = 20.0f;
		pt.position.z = 00.0f;
		pt.range = 300.0f;
		pt.color.x = 1.0f;
		pt.color.y = 1.0f;
		pt.color.z = 1.0f;
	}
}

void SkinModel::InitDirectionLight()
{
	m_dirLight.dir.Direction[0] = { 1.0f, 0.0f, 0.0f, 0.0f };
	m_dirLight.dir.Color[0] = { 0.0f, 0.0f, 0.0f, 1.0f };

	//これを太陽光とする
	m_dirLight.dir.Direction[1] = { -1.0f, -1.0f, -1.0f, 0.0f };
	m_dirLight.dir.Direction[1].Normalize();
	m_dirLight.dir.Color[1] = { 1.2f, 1.2f, 1.2f, 1.0f };

	m_dirLight.dir.Direction[2] = { 0.0f, 0.0f, 1.0f, 0.0f };
	m_dirLight.dir.Color[2] = { 0.2f, 0.2f, 0.2f, 1.0f };

	m_dirLight.dir.Direction[3] = { 1.0f, 1.0f, -1.0f, 0.0f };
	m_dirLight.dir.Direction[3].Normalize();
	m_dirLight.dir.Color[3] = { 0.2f, 0.2f, 0.2f, 1.0f };
	m_dirLight.eyePos = g_camera3D.GetPosition();
	m_dirLight.pow = 5.0f;
}

void SkinModel::InitConstantBuffer()
{
	//作成するバッファのサイズをsizeof演算子で求める。
	int bufferSize = sizeof(SVSConstantBuffer);
	//どんなバッファを作成するのかをせてbufferDescに設定する。
	D3D11_BUFFER_DESC bufferDesc;
	ZeroMemory(&bufferDesc, sizeof(bufferDesc));				//０でクリア。
	bufferDesc.Usage = D3D11_USAGE_DEFAULT;						//バッファで想定されている、読み込みおよび書き込み方法。
	bufferDesc.ByteWidth = (((bufferSize - 1) / 16) + 1) * 16;	//バッファは16バイトアライメントになっている必要がある。
																//アライメントって→バッファのサイズが16の倍数ということです。
	bufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;			//バッファをどのようなパイプラインにバインドするかを指定する。
																//定数バッファにバインドするので、D3D11_BIND_CONSTANT_BUFFERを指定する。
	bufferDesc.CPUAccessFlags = 0;								//CPU アクセスのフラグです。
																//CPUアクセスが不要な場合は0。
	//作成。
	g_graphicsEngine->GetD3DDevice()->CreateBuffer(&bufferDesc, NULL, &m_cb);

	bufferDesc.ByteWidth = (((sizeof(Light)) / 16) + 1) * 16;				//SDirectionLightは16byteの倍数になっているので、切り上げはやらない。
	g_graphicsEngine->GetD3DDevice()->CreateBuffer(&bufferDesc, NULL, &m_light); 

	bufferDesc.ByteWidth = (((sizeof(PointLight)) / 16) + 1) * 16;
	g_graphicsEngine->GetD3DDevice()->CreateBuffer(&bufferDesc, NULL, &m_PointLightBuffer);
}
void SkinModel::InitSamplerState()
{
	//テクスチャのサンプリング方法を指定するためのサンプラステートを作成。
	D3D11_SAMPLER_DESC desc;
	ZeroMemory(&desc, sizeof(desc));
	desc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
	desc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
	desc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
	desc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
	g_graphicsEngine->GetD3DDevice()->CreateSamplerState(&desc, &m_samplerState);
}
void SkinModel::UpdateWorldMatrix(CVector3 position, CQuaternion rotation, CVector3 scale)
{
	//3dsMaxと軸を合わせるためのバイアス。
	CMatrix mBias = CMatrix::Identity();
	if (m_enFbxUpAxis == enFbxUpAxisZ) {
		//Z-up
		mBias.MakeRotationX(CMath::PI * -0.5f);
	}
	CMatrix transMatrix, rotMatrix, scaleMatrix;
	//平行移動行列を作成する。
	transMatrix.MakeTranslation( position );
	//回転行列を作成する。
	rotMatrix.MakeRotationFromQuaternion( rotation );
	rotMatrix.Mul(mBias, rotMatrix);
	//拡大行列を作成する。
	scaleMatrix.MakeScaling(scale);
	//ワールド行列を作成する。
	//拡大×回転×平行移動の順番で乗算するように！
	//順番を間違えたら結果が変わるよ。
	m_worldMatrix.Mul(scaleMatrix, rotMatrix);
	m_worldMatrix.Mul(m_worldMatrix, transMatrix);

	//スケルトンの更新。
	m_skeleton.Update(m_worldMatrix);
}
void SkinModel::Draw(CMatrix viewMatrix, CMatrix projMatrix)
{
	DirectX::CommonStates state(g_graphicsEngine->GetD3DDevice());

	ID3D11DeviceContext* d3dDeviceContext = g_graphicsEngine->GetD3DDeviceContext();

	m_dirLight.eyePos = g_camera3D.GetPosition();
	d3dDeviceContext->UpdateSubresource(m_light, 0, nullptr, &m_dirLight, 0, 0);
	d3dDeviceContext->PSSetConstantBuffers(1, 1, &m_light);

	d3dDeviceContext->UpdateSubresource(m_PointLightBuffer, 0, nullptr, &m_pointLight, 0, 0);
	d3dDeviceContext->PSSetConstantBuffers(2, 1, &m_PointLightBuffer);


	//定数バッファの内容を更新。
	SVSConstantBuffer vsCb;
	vsCb.mWorld = m_worldMatrix;
	vsCb.mProj = projMatrix;
	vsCb.mView = viewMatrix;
	vsCb.mLightProj = g_graphicsEngine->GetShadowMap()->GetLightProjMatrix();
	vsCb.mLightView = g_graphicsEngine->GetShadowMap()->GetLightViewMatrox();
	vsCb.emissionColor = m_emissionColor;
	d3dDeviceContext->UpdateSubresource(m_cb, 0, nullptr, &vsCb, 0, 0);
	//定数バッファをGPUに転送。
	d3dDeviceContext->VSSetConstantBuffers(0, 1, &m_cb);
	d3dDeviceContext->PSSetConstantBuffers(0, 1, &m_cb);
	//サンプラステートを設定。
	d3dDeviceContext->PSSetSamplers(0, 1, &m_samplerState);
	//ボーン行列をGPUに転送。
	m_skeleton.SendBoneMatrixArrayToGPU();

	switch (m_renderMode)
	{
		//通常描画
	case enNormalDraw:
		//通常描画
		m_modelDx->UpdateEffects([&](DirectX::IEffect* material) {
			auto modelMaterial = reinterpret_cast<ModelEffect*>(material);
			//通常描画
			modelMaterial->SetRenderMode(enNormalDraw);
		});

		//描画。                                                                           
		m_modelDx->Draw(
			d3dDeviceContext,
			state,
			m_worldMatrix,
			viewMatrix,
			projMatrix
		);
		break;
		//シルエット描画→通常描画
	case enSilhouetteDraw:

		m_modelDx->UpdateEffects([&](DirectX::IEffect* material) {
			auto modelMaterial = reinterpret_cast<ModelEffect*>(material);
			//シルエット描画
			modelMaterial->SetRenderMode(enSilhouetteDraw);
		});

		//描画。                                                                           
		m_modelDx->Draw(
			d3dDeviceContext,
			state,
			m_worldMatrix,
			viewMatrix,
			projMatrix
		);
		m_modelDx->UpdateEffects([&](DirectX::IEffect* material) {
			auto modelMaterial = reinterpret_cast<ModelEffect*>(material);
			//通常描画に切り替え
			modelMaterial->SetRenderMode(enNormalDraw);
		});

		//描画。                                                                           
		m_modelDx->Draw(
			d3dDeviceContext,
			state,
			m_worldMatrix,
			viewMatrix,
			projMatrix
		);
		break;
	case enShadowDraw:
		m_modelDx->UpdateEffects([&](DirectX::IEffect* material) {
			auto modelMaterial = reinterpret_cast<ModelEffect*>(material);
			//シャドウ描画
			modelMaterial->SetRenderMode(enShadowDraw);
		});
		//描画。                                                                           
		m_modelDx->Draw(
			d3dDeviceContext,
			state,
			m_worldMatrix,
			viewMatrix,
			projMatrix
		);
		////通常描画
		//m_modelDx->UpdateEffects([&](DirectX::IEffect* material) {
		//	auto modelMaterial = reinterpret_cast<ModelEffect*>(material);
		//	//通常描画
		//	modelMaterial->SetRenderMode(enNormalDraw);
		//});

		////描画。                                                                           
		//m_modelDx->Draw(
		//	d3dDeviceContext,
		//	state,
		//	m_worldMatrix,
		//	viewMatrix,
		//	projMatrix
		//);
	default:
		break;
	}
	//m_renderTarget.OffScreenRendering();

	//m_modelDx->UpdateEffects([&](DirectX::IEffect* material) {
	//	auto modelMaterial = reinterpret_cast<ModelEffect*>(material);
	//	//差し替え前のテクスチャをスタックに退避。
	//	modelMaterial->PushAlbedoTexture();
	//	//テクスチャを差し替える。
	//	//modelMaterial->SetAlbedoTexture(m_renderTarget.GetRTSRV());
	//	//シルエット描画に切り替え
	//	modelMaterial->SetRenderMode(1);
	//});
	////QueryMaterials([&](ModelEffect* material) {
	////	//差し替え前のテクスチャをスタックに退避。
	////	material->PushAlbedoTexture();
	////	//テクスチャを差し替える。
	////	material->SetAlbedoTexture(m_renderTarget.GetRTSRV());
	////});

	////描画。                                                                           
	//m_modelDx->Draw(
	//	d3dDeviceContext,
	//	state,
	//	m_worldMatrix,
	//	viewMatrix,
	//	projMatrix
	//);

	////m_renderTarget.OnScreenRendering();

	//////背景のテクスチャを元に戻す。
	//m_modelDx->UpdateEffects([&](DirectX::IEffect* material) {
	//	auto modelMaterial = reinterpret_cast<ModelEffect*>(material);
	//	//差し替え前のテクスチャをスタックから復帰。
	//	modelMaterial->PopAlbedoTexture();
	//	//通常描画に戻す
	//	modelMaterial->SetRenderMode(0);
	//});

	////描画。                                                                           
	//m_modelDx->Draw(
	//	d3dDeviceContext,
	//	state,
	//	m_worldMatrix,
	//	viewMatrix,
	//	projMatrix
	//);
}